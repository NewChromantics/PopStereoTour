<!DOCTYPE html>
<html lang="en">
<head>
	<title>360 Viewer</title>
	<meta charset="utf-8" />
	
	<style type="text/css">
		
		body
		{
		xxxbackground-color:	#0ff;
		color:				#000;
		font-family:		"futura-pt",sans-serif;
		margin:				0px;
		padding:			0px;
		overflow:			hidden;
		}
	</style>
</head>
<body>
	<script src="PopWebgl/PopGl.js"></script>
	<script src="PopWebgl/PopBlitter.js"></script>
	<script src="PopWebgl/gl-matrix-min.js"></script>
	
	<canvas id="glcanvas" width="100" height="100">
		Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
	</canvas>
<script>


var VertexShader_Stereo360 = `
attribute vec2 a_position;
varying vec2 uv;
void main()
{
	vec2 Pos2 = mix( vec2(-1,-1), vec2(1,1), a_position );
	gl_Position = vec4(Pos2, 0.0, 1.0);
	uv = vec2( a_position.x, 1.0-a_position.y);
	
	uv.x = mix( 0.0, 1.0, uv.x );
	uv.y = mix( 0.0, 1.0, uv.y );
}
`;

var FragShader_Stereo360 = `
precision highp float;
varying vec2 uv;
uniform sampler2D Texture;
uniform mat4 ViewToScreenMatrix;
uniform mat4 ScreenToViewMatrix;
#define UNITY_PI 3.1415926535897932384626433832795
uniform vec4 PanoMinMax;

float atan2(float x,float y)
{
	return atan(x,y);
}

vec2 ViewToEquirect(vec3 View3)
{
	View3 = normalize(View3);
	vec2 longlat = vec2(atan2(View3.x, View3.z) + UNITY_PI, acos(-View3.y));
	vec2 uv = longlat / vec2(2.0 * UNITY_PI, UNITY_PI);
	return uv;
}

vec3 GetUvColour(vec2 uv)
{
	if ( uv.x < 0.0 || uv.y < 0.0 )
		return vec3( 0, 0, 1 );
	if ( uv.x > 1.0 || uv.y > 1.0 )
		return vec3( 1, 0, 1 );
		
	vec2 Edge = uv * 40.0;
	Edge = fract(Edge);
	if ( Edge.x < 0.1 )
		return vec3(1,1,1);
	if ( Edge.y < 0.1 )
		return vec3(1,1,1);

	return vec3( uv, 0 );
}

vec2 ScaleMinMax(vec2 uv,vec4 MinMax)
{
	float u = mix( MinMax.x, MinMax.z, uv.x );
	float v = mix( MinMax.y, MinMax.w, uv.y );
	return vec2(u,v);
}

void main()
{
	//	projection space is -1..1
	vec2 Screen2 = mix( vec2(-1,1), vec2(1,-1), uv );
	//vec2 Screen2 = mix( vec2(0,0), vec2(1,1), uv );
	float Zoom = 1.0;
	vec4 Screen = vec4( Screen2, Zoom, 0 );
	
	//vec4 View4 = ScreenToViewMatrix * Screen;
	vec4 View4 = Screen * ViewToScreenMatrix ;
	vec3 View3 = View4.xyz / View4.w;
	//vec3 View3 = View4.xyz;
	
	vec2 EquirectUv = ViewToEquirect( View3 );
	EquirectUv = ScaleMinMax( EquirectUv, PanoMinMax );
	gl_FragColor = texture2D( Texture, EquirectUv );
	//gl_FragColor = vec4( GetUvColour(EquirectUv), 1 );
}
`;

function TCamera()
{
	this.VerticalFieldOfView = 100;
	this.NearClipDistance = 1.0;
	this.FarClipDistance = 100.0;
	this.RotationEularDegrees = new float3(0,0,0);
	this.Translation = new float3(0,0,0);

	this.GetViewToScreenMatrix = function(RenderTarget)
	{
		let w = RenderTarget.GetViewportWidth();
		let h = RenderTarget.GetViewportHeight();
		let aspect = w/h;
		let vfov = Math.radians( this.VerticalFieldOfView );
		
		let pm = new Matrix4x4();
		mat4.perspective( pm.Values, vfov, aspect, this.NearClipDistance, this.FarClipDistance );
		
		let YawRadians = Math.radians( this.RotationEularDegrees.y );
		let PitchRadians = Math.radians( this.RotationEularDegrees.x );
		mat4.rotateY( pm.Values, pm.Values, YawRadians );
		mat4.rotateX( pm.Values, pm.Values, PitchRadians );
		return pm;
	}
	
	this.GetScreenToViewMatrix = function(RenderTarget)
	{
		let ViewToScreen = this.GetViewToScreenMatrix(RenderTarget);
		ViewToScreen.Invert();
		return ViewToScreen;
	}
}

const MinMax_Full = new float4(0,0,1,1);
const MinMax_Left = new float4(0,0,0.5,1.0);
const MinMax_Right = new float4(0.5,0,1.0,1.0);
const MinMax_Top = new float4(0,0,1,0.5);
const MinMax_Bottom = new float4(0,0.5,1.0,1.0);

	function GetPanoMinMaxUvsFromFilename(Filename)
	{
		//	mike's _s is top/bottom
		if ( Filename.endsWith('_s') )
		{
			return [ MinMax_Top, MinMax_Bottom ];
		}
		
		return [ MinMax_Full ];
	}


	window.onload = main;
	
	

	function main()
	{
		var Canvas = document.getElementById('glcanvas');
		var Context = new TContext( Canvas );
		var ScreenLeft = new TScreen( Canvas, MinMax_Left );
		var ScreenRight = new TScreen( Canvas, MinMax_Right );
		var ScreenFull = new TScreen( Canvas );

//	force 1:1 ratio
		Screen.GetWidth = function()
		{
			return Math.max( this.CanvasElement.width, this.CanvasElement.height );
		}
		Screen.GetHeight = function()
		{
			return Math.max( this.CanvasElement.width, this.CanvasElement.height );
		}

		var ResizeCanvas = function()
		{
			console.log("ResizeCanvas");
			Canvas.width = window.innerWidth;
			//	gr: where did this border come from?
			Canvas.height = window.innerHeight+4;
		}

		// resize the canvas to fill browser window dynamically
		window.addEventListener('resize', ResizeCanvas, false);
		ResizeCanvas();
		
		
		let ClearColour = new float4(0,0,0,1);
		let PanoUrl = 'http://stereo360.newchromantics.com/Images/cam1_s.jpg';
		//let PanoUrl = 'http://stereo360.newchromantics.com/Images/Test360.jpg';
		let PanoTexture = new TTexture('Pano',PanoUrl);
		let Stereo360Blitter = new TBlitter('Blitter', FragShader_Stereo360 );
		let Camera = new TCamera();

		function LoadPanoImage(Url,Name)
		{
			PanoTexture.Load(Url,Name);
		}

		//	enable drag & drop
		function OnDropFile(evt)
		{
			evt.stopPropagation();
			evt.preventDefault();
			
			var files = evt.dataTransfer.files; // FileList object.
			
			for (var i = 0, f; f = files[i]; i++)
			{
				var reader = new FileReader();
				console.log(f);
				let Filename = f.name;
				
				var OnLoadImageFile = function(e)
				{
					var DataUri = e.target.result;
					console.log(e);
					LoadPanoImage(DataUri,Filename);
				};
				reader.onload = OnLoadImageFile;
				reader.readAsDataURL(f);
			}
		}
		
		function OnDragOver(evt)
		{
			evt.stopPropagation();
			evt.preventDefault();
			evt.dataTransfer.dropEffect = 'copy';
		}
		
		let DropElement = Canvas;
		DropElement.addEventListener('dragover', OnDragOver, false);
		DropElement.addEventListener('drop', OnDropFile, false);





		let SetStereoUniforms = function(Shader,Geo,RenderTarget)
		{
			let PanoUvs = GetPanoMinMaxUvsFromFilename( PanoTexture.GetFilenameNoExtension() );
			let PanoMinMax = PanoUvs[0];
			if ( RenderTarget == ScreenRight )
				PanoMinMax = PanoUvs[PanoUvs.length-1];
			
			let ViewToScreenMatrix = Camera.GetViewToScreenMatrix(RenderTarget);
			let ScreenToViewMatrix = Camera.GetScreenToViewMatrix(RenderTarget);
			Shader.SetUniform( 'ViewToScreenMatrix', ViewToScreenMatrix );
			Shader.SetUniform( 'ScreenToViewMatrix', ScreenToViewMatrix );
			Shader.SetUniform( 'Texture', PanoTexture );
			Shader.SetUniform( 'PanoMinMax', PanoMinMax );
		};
		
		var Time = 0;
		function Render()
		{
			Time += 1.0 / 60.0;
			//Camera.RotationEularDegrees.x = Math.sin( Time ) * 10;
			Camera.RotationEularDegrees.y += 0.2;
			
			let PanoUvs = GetPanoMinMaxUvsFromFilename( PanoTexture.GetFilenameNoExtension() );
			let RenderStereo = PanoUvs.length > 1;
			
			try
			{
				if ( RenderStereo )
				{
					Stereo360Blitter.Render( ScreenLeft, SetStereoUniforms );
					Stereo360Blitter.Render( ScreenRight, SetStereoUniforms );
				}
				else
				{
					Stereo360Blitter.Render( ScreenFull, SetStereoUniforms );
				}
			}
			catch(Exception)
			{
				//	rethrow
				throw Exception;
			}
			finally
			{
				//	always request redraw
				requestAnimationFrame( Render );
			}
		}

		Render();
	}


</script></body>
</html>
