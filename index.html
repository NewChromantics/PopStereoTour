<!DOCTYPE html>
<html lang="en">
<head>
	<title>nay way Jose</title>
	<meta charset="utf-8" />
	
	<style type="text/css">
		
		body
		{
		xxxbackground-color:	#0ff;
		color:				#000;
		font-family:		"futura-pt",sans-serif;
		margin:				0px;
		padding:			0px;
		overflow:			hidden;
		}
	</style>
</head>
<body>
	<script src="PopWebgl/PopGl.js"></script>
	<script src="PopWebgl/PopBlitter.js"></script>
	<script src="PopWebgl/gl-matrix-min.js"></script>
	
	<canvas id="glcanvas" width="100" height="100">
		Your browser doesn't appear to support the HTML5 <code>&lt;canvas&gt;</code> element.
	</canvas>
<script>


var VertexShader_Stereo360 = `
attribute vec2 a_position;
varying vec2 uv;
void main()
{
	vec2 Pos2 = mix( vec2(-1,-1), vec2(1,1), a_position );
	gl_Position = vec4(Pos2, 0.0, 1.0);
	uv = vec2( a_position.x, 1.0-a_position.y);
	
	uv.x = mix( 0.0, 1.0, uv.x );
	uv.y = mix( 0.0, 1.0, uv.y );
}
`;

var FragShader_Stereo360 = `
precision highp float;
varying vec2 uv;
uniform sampler2D Texture;
uniform mat4 ViewToScreenMatrix;
uniform mat4 ScreenToViewMatrix;
#define UNITY_PI 3.1415926535897932384626433832795

float atan2(float x,float y)
{
	return atan(y,x);
}

vec2 ViewToEquirect(vec3 View3)
{
	View3 = normalize(View3);
	vec2 longlat = vec2(atan2(View3.x, View3.z) + UNITY_PI, acos(-View3.y));
	vec2 uv = longlat / vec2(2.0 * UNITY_PI, UNITY_PI);
	return uv;
}

void main()
{
	//	projection space is -1..1
	vec2 Screen2 = mix( vec2(-1,-1), vec2(1,1), uv );
	vec4 Screen = vec4( Screen2, 1, 0 );
	
	//vec4 View4 = ScreenToViewMatrix * Screen;
	vec4 View4 = ViewToScreenMatrix * Screen;
	//vec3 View3 = View4.xyz / View4.w;
	vec3 View3 = View4.xyz;
	
	vec2 EquirectUv = ViewToEquirect( View3 );
	gl_FragColor = texture2D( Texture, EquirectUv );
}
`;

function TCamera()
{
	this.VerticalFieldOfView = 45;
	this.NearClipDistance = 0.01;
	this.FarClipDistance = 100.0;
	this.RotationEularDegrees = new float3(0,0,0);
	this.Translation = new float3(0,0,0);

	this.GetViewToScreenMatrix = function(RenderTarget)
	{
		let w = RenderTarget.GetWidth();
		let h = RenderTarget.GetHeight();
		let aspect = w/h;
		let vfov = Math.radians( this.VerticalFieldOfView );
		
		let pm = new Matrix4x4();
		mat4.perspective( pm.Values, vfov, aspect, this.NearClipDistance, this.FarClipDistance );
		
		let YawRadians = Math.radians( this.RotationEularDegrees.y );
		mat4.rotateY( pm.Values, pm.Values, YawRadians );
		return pm;
	}
	
	this.GetScreenToViewMatrix = function(RenderTarget)
	{
		let ViewToScreen = this.GetViewToScreenMatrix(RenderTarget);
		ViewToScreen.Invert();
		return ViewToScreen;
	}
}



	window.onload = main;

	function main()
	{
		var Canvas = document.getElementById('glcanvas');
		var Context = new TContext( Canvas );
		var Screen = new TScreen( Canvas );

//	force 1:1 ratio
		Screen.GetWidth = function()
		{
			return Math.max( this.CanvasElement.width, this.CanvasElement.height );
		}
		Screen.GetHeight = function()
		{
			return Math.max( this.CanvasElement.width, this.CanvasElement.height );
		}

		var ResizeCanvas = function()
		{
			console.log("ResizeCanvas");
			Canvas.width = window.innerWidth;
			//	gr: where did this border come from?
			Canvas.height = window.innerHeight+4;
		}

		// resize the canvas to fill browser window dynamically
		window.addEventListener('resize', ResizeCanvas, false);
		ResizeCanvas();
		
		let ClearColour = new float4(0,0,0,1);
		let PanoUrl = 'http://stereo360.newchromantics.com.s3-website-us-west-2.amazonaws.com/Images/cam1.jpg';
		let PanoTexture = new TTexture('Pano',PanoUrl);
		let Stereo360Blitter = new TBlitter('Blitter', FragShader_Stereo360 );
		let Camera = new TCamera();

		let SetStereoUniforms = function(Shader,Geo,RenderTarget)
		{
			let ViewToScreenMatrix = Camera.GetViewToScreenMatrix(RenderTarget);
			let ScreenToViewMatrix = Camera.GetScreenToViewMatrix(RenderTarget);
			Shader.SetUniform( 'ViewToScreenMatrix', ViewToScreenMatrix );
			Shader.SetUniform( 'ScreenToViewMatrix', ScreenToViewMatrix );
			Shader.SetUniform( 'Texture', PanoTexture );
			Shader.SetUniform( 'ViewForward', new float3(0,0,1) );
		};
		

		function Render()
		{
			Camera.RotationEularDegrees.y += 0.2;
			try
			{
				Stereo360Blitter.Render( Screen, SetStereoUniforms );
			}
			catch(Exception)
			{
				//	rethrow
				throw Exception;
			}
			finally
			{
				//	always request redraw
				requestAnimationFrame( Render );
			}
		}

		Render();
	}


</script></body>
</html>
